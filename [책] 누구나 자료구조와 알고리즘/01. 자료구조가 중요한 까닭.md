# 01. 자료 구조가 중요한 까닭

## 1.1. 자료 구조

**데이터**

- 일반적으로 모든 유형의 정보를 망라하는 용어
- 가장 기초적인 수와 문자열로 이루어진다. 매우 복잡한 데이터라도 대개는 수와 문자열의 묶음으로 나눠진다.

**자료 구조**

- **데이터를 조직**하는 방법
- 데이터 조직은 코드의 실행 속도에 영향을 미친다.

## 1.2. 배열

### 배열

- 컴퓨터 과학에서 기초적인 자료 구조
- 단순히 데이터 원소들의 리스트

### 배열에 쓰이는 용어

1. **배열의 크기** : 배열에 데이터 원소가 얼마나 들어있는지
2. **배열의 인덱스** : 특정 데이터의 배열에서의 위치. 대부분 0이 시작

### 자료 구조 연산

자료 구조의 성능을 알려면, 코드가 자료 구조와 일반적으로 어떻게 상호작용하는 분석해야 한다.

대부분의 자료구조는 네 가지 기본 방법을 사용하고, **연산**이라 부른다.

1. 읽기 : 자료 구조 내 특정 위치를 찾아보는 것
2. 검색 : 자료 구조 내에서 특정 값을 찾는 것
3. 삽입 : 자료 구조에 새로운 값을 추가하는 것
4. 삭제 : 자료 구조에서 값을 제거하는 것

**배열에서의 연산**

1. 읽기 : 특정 인덱스를 찾는 것.
2. 검색 : 특정 값이 배열에 들어 있는지, 어떤 인덱스에 있는지 알아보는 것.
3. 삽입 : 배열 내에 슬롯을 더 만들어 새 값을 추가하는 것.
4. 삭제 : 배열의 값 중 하나를 제거하는 것.

## 1.3. 속도 측정

연산의 속도 측정 기준은 **계산 단계의 개수**이다.

- 연산이 빠르다 ≠ 시간이 덜 걸린다.
- 연산이 빠르다 = **더 적은 단계를 거친다.**

실행하는 하드웨어에 따라 시간이 다를 수 있으므로, 시간을 기준으로 속도를 측정하는 것은 신뢰도가 떨어진다.

연산의 속도 = 시간 복잡도 = 효율성 = 성능 모두 같은 의미로 사용될 수 있다.

## 1.4. 읽기

배열 읽기 : 배열 내 특정 인덱스에 어떤 값이 들어 있는지 찾아보는 것

### 컴퓨터의 메모리

- 메모리는 셀로 구성된 거대한 컬렉션이다.
- 배열을 선언하면, 컴퓨터는 메모리의 연속된 빈 셀들의 집합을 할당한다.
- 메모리마다 고유한 주소가 있고, 순차적으로 1씩 증가한다.

### 배열 읽기의 단계

배열의 읽기는 배열의 크기와 상관 없이 **항상 한 단계**만 걸린다.

**배열의 첫 번째 값을 한 번에 찾아낼 수 있는 이유**

1. 컴퓨터는 모든 메모리 주소에 한 번에 갈 수 있다.
2. 배열을 메모리에 할당할 때, 시작되는 메모리 셀의 주소가 기록된다.

**배열 읽기 명령을 받으면, 컴퓨터는 다음 과정을 거친다.**

1. 배열 인덱스 0의 주소를 알아낸다.
2. 1의 주소에 찾을 인덱스만큼 더한다.

**배열 읽기는 매우 효율적인 연산**

- 어떤 메모리 주소에든 한 번에 접근해 어떤 인덱스든 읽을 수 있다.
- 한 단계로 끝나는 연산은 가장 빠른 연산이다.

## 1.5. 검색

배열 검색 : 배열에 특정 값이 있는지 알아본 후, 있다면 어떤 인덱스에 있는지 찾는 것

### 읽기와 검색

읽기와 검색은 효율성에서 차이가 난다.

컴퓨터는 모든 메모리 주소에 한 번에 접근하지만<span style="color: cadetblue">(읽기)</span>, 각 메모리 주소에 어떤 값이 있는지 바로 알지 못한다<span style="color: cadetblue">(검색)</span>.

**읽기**

- 컴퓨터에 인덱스를 제공하고, 그 인덱스에 있는 들어 있는 값을 반환하라고 요청한다.
- 컴퓨터가 어떤 인덱스든 바로 가서 인덱스에 있는 값을 찾을 수 있으니 매우 빠르다.

**검색**

- 컴퓨터에 값을 제공하고, 그 값이 들어 있는 인덱스를 반환하라고 요청한다.
- 컴퓨터가 특정 값으로 바로 갈 수 없어 오래 걸린다.

### 검색의 단계 수

**선형 검색**

- 컴퓨터가 한 번에 한 셀씩 확인하는 방법
- 찾으려던 값을 발견할 때까지 셀을 확인하므로, 찾으려던 값이 있는 인덱스의 수만큼 단계수가 걸린다.
- 찾는 값이 마지막 셀에 있다면 이 값을 발견할 때까지 모든 셀을 검색한다.
- 찾는 값이 없는 경우에도 모든 셀을 검색해야 한다.
- N개의 셀로 이루어진 배열을 선형 검색하는 경우, **최대 단계의 수는 N**이다.

읽기는 배열의 크기와 상관없이 항상 한 단계만 걸리지만, 검색에는 많은 단계가 걸릴 수 있다.

## 1.6. 삽입

배열의 어디에 데이터를 삽입하는가에 따라 효율성이 다르다.

### 배열의 맨 끝에 삽입

① 새 값을 삽입할 메모리 주소를 계산

- 컴퓨터는 배열이 시작되는 메모리 주소를 안다
- 배열 마지막 항목의 메모리 주소를 계산하기 쉽다

② 배열에 셀을 추가로 할당

### 중간에 데이터를 삽입

삽입할 공간을 만들기 위해 많은 데이터 조각을 이동시켜야하므로 단계가 늘어난다.

### 맨 앞에 삽입

배열 내 모든 값을 한 셀씩 오른쪽으로 옮겨야 한다.

### 최악의 시나리오

원소 N개를 포함하는 배열에서 최악의 시나리오 : **N+1단계**가 걸린다.

N개의 원소를 전부 이동시키고, 실제 삽입 단계를 실행해야 하기 때문

## 1.7. 삭제

배열의 삭제 : 특정 인덱스의 값을 제거하는 과정

### 삭제의 단계

1. 실제 삭제
2. 빈 공간을 메꾸는 데이터 이동

### 최악의 시나리오

배열의 첫 번째 원소를 삭제할 때 최악의 시나리오.

1. 배열의 0번째 인덱스 삭제
2. 남아 있는 모든 원소를 왼쪽으로 이동시켜 빈 공간을 채워야 한다.

원소 N개를 포함하는 배열에서 삭제에 필요한 최대 단계 수는 **N단계**

## 배열의 단계 요약

1. 읽기 : 항상 한 단계
2. 검색 : 최대 N단계
3. 삽입 : 최대 N+1단계
4. 삭제 : 최대 N단계

## 1.8. 집합 : 단 하나의 규칙으로 효율성이 달라진다

### 집합

집합은 중복 값을 허용하지 않는 자료구조

배열 기반 집합과 일반 배열의 유일한 차이점 : **집합은 중복 값의 삽입을 절대 허용하지 않는다**

### 집합의 연산과 효율성

#### 읽기

- 배열 읽기와 같다.
- 특정 인덱스에 있는 값을 **한 단계**만에 찾는다.

#### 검색

- 배열 검색과 같다.
- **최대 N단계**가 걸린다.

#### 삭제

- 배열의 삭제와 같다.
- **최대 N단계** : 값을 삭제하고 데이터를 왼쪽으로 옮겨 빈 공간을 메꾼다.

#### 삽입

삽입할 값이 집합에 존재하는지 먼저 **검색 단계**를 거친다.

**<집합의 끝에 삽입하는 경우>**

원소 N개에 대해 최대 **N+1단계**가 필요하다.

1. 값에 집합에 없음을 확인하는 N단계
2. 실제 삽입에 한 단계

**<집합의 맨 앞에 삽입하는 경우 - 최악의 시나리오>**

원소 N개에 대해 **2N+1단계**가 필요하다.

1. 컴퓨터는 셀 N개를 검색해서 집합이 그 값을 포함하지 않음을 확인하는 검색 단계 (N단계)
2. 모든 데이터를 오른쪽으로 옮기는 N단계
3. 새 값을 삽입하는 한 단계

### 집합과 배열의 선택

삽입 연산이 일반적인 배열보다 집합에서 느리다는 이유로 집합을 무조건 사용하지 않아야 하는 것은 아니다. 중복 데이터가 없어야 할 때는 집합을 사용하는 것이 좋다.

애플리케이션의 요구사항을 먼저 분석한 후, 어떤 자료 구조가 더 적합한지 결정한다.
